;;; purpose-prefix-overload.el --- Bind several commands to the same key -*- lexical-binding: t -*-

;; Author: Bar Magal (2015)
;; Package: purpose

;;; Commentary:
;; This file contains functions and macros for using the same
;; key-binding for several commands (overloading). The correct command
;; is chosen by considering the prefix argument.
;;
;; For example, this binds `ido-find-file' and
;; `find-file-without-purpose' to C-x C-f:
;;    (def-prefix-overload purpose-find-file-overload
;;      '(ido-find-file find-file-without-purpose))
;;    (define-key purpose-mode-map (kbd "C-x C-f")
;;      #'purpose-find-file-overload)
;; To call `ido-find-file', the user presses C-x C-f. To call
;; `find-file-without-purpose', the user presses C-u C-x C-f.

;;; Code:

(require 'cl-lib)

(defun purpose--prefix-arg-to-index (prefix-arg)
  "Turn prefix argument PREFIX-ARG to a logical index.
Examples:
C-u <command>: index 1
C-u C-u <command>: index 2
C-u 2 <command>: index 2
C-u 1 2 <command>: index 12
<command>: index 0 (no prefix argument used)"
  (cond
   ((null prefix-arg)
    0)
	
   ((listp prefix-arg)
    (floor (log (car prefix-arg) 4)))

   ((eq prefix-arg '-)
    -1)
   
   (t
    prefix-arg)))

(defun purpose--generate-documentation-def-prefix-overload (name commands)
  (let ((doc-first (format "\\[%s]: `%s'" name (car commands)))
	(doc-rest
	 (cl-loop for c in (cdr commands)
		  for i from 1
		  collect (format "%s \\[%s], C-u %s \\[%s]: `%s'"
				  (mapconcat #'identity
					     (cl-loop for j from 1 to i
						      collect "C-u")
					     " ")
				  name
				  i
				  name
				  c))))
    (mapconcat
     #'identity
     (append
      (list "This function was generated by `define-purpose-prefix-overload'."
	    ""
	    doc-first)
      doc-rest)
     "\n")))

(defmacro define-purpose-prefix-overload (name commands)
  "Define an interactive function named NAME, which calls interactively
one command from COMMANDS.
The command is chosen by the prefix argument:
no prefix argument: first command;
C-u or C-u 1: second command;
C-u C-u or C-u 2: third command;
and so on.
Use it like this:
   (define-purpose-prefix-overload hello '(command1 command2 command3))"
  (unless (eval commands)
    (error "Argument COMMANDS cannot be empty"))
  `(defun ,name (&optional arg)
     ,(purpose--generate-documentation-def-prefix-overload name (eval commands))
     (interactive "P")
     (let* ((index (purpose--prefix-arg-to-index arg))
	    (command (nth index ,commands)))
       (if command
	   (call-interactively command)
	 (error "Index %s too big" index)))))

(provide 'purpose-prefix-overload)
;;; purpose-prefix-overload.el ends here
