;;; pu-prefix-overload.el

;; Author: Bar Magal (2015)
;; Package: purpose
;; Version: 0.1.2

;;; Commentary:
;; This file contains functions and macros for using the same
;; key-binding for several commands (overloading). The correct command
;; is chosen by considering the prefix argument.
;;
;; For example, this binds `pu:find-file' and `find-file' to C-x C-f:
;;    (def-prefix-overload pu:find-file-overload '(pu:find-file find-file))
;;    (define-key purpose-mode-map (kbd "C-x C-f") #'pu:find-file-overload)
;; To call `pu:find-file', the user presses C-x C-f. To call
;; `find-file', the user presses C-u C-x C-f.

;;; Code:

(defun pu:prefix-arg-to-index (prefix-arg)
  "Turn prefix argument to a logical index. Examples:
C-u <command>: index 1
C-u C-u <command>: index 2
C-u 2 <command>: index 2
C-u 1 2 <command>: index 12
<command>: index 0 (no prefix argument used)"
  (cond
   ((null prefix-arg)
    0)
	
   ((listp prefix-arg)
    (floor (log (car prefix-arg) 4)))

   ((eq prefix-arg '-)
    -1)
   
   (t
    prefix-arg)))

(defun pu:generate-documentation-def-prefix-overload (name commands)
  (let ((doc-first (format "\\[%s]: `%s'" name (symbol-name (car commands))))
	(doc-rest
	 (loop for c in (cdr commands)
	       for i from 1
	       collect (format "%s \\[%s], C-u %s \\[%s]: `%s'"
			       (mapconcat #'identity
					  (loop for j from 1 to i
						collect "C-u")
					  " ")
			       name
			       i
			       name
			       (symbol-name c)))))
    (mapconcat
     #'identity
     (append (list "This function was generated by `pu:def-prefix-overload'."
		   ""
		   doc-first)
	     doc-rest)
     "\n")))

(defmacro pu:def-prefix-overload (name commands)
  "Define an interactive function named NAME, which calls interactively
one command from COMMANDS. The command is chosen by the prefix argument:
no prefix argument: first command;
C-u or C-u 1: second command;
C-u C-u or C-u 2: third command;
and so on.
Use it like this: 
    (pu:def-prefix-overload hello '(command1 command2 command3))"
  (unless (eval commands)
    (error "Argument COMMANDS cannot be empty"))
  `(defun ,name (&optional arg)
     ,(pu:generate-documentation-def-prefix-overload name (eval commands))
     (interactive "P")
     (let* ((index (pu:prefix-arg-to-index arg))
	    (command (nth index ,commands)))
       (if command
	   (call-interactively command)
	 (error "Index %s too big" index)))))

(provide 'pu-prefix-overload)
